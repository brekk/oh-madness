import { always } from "Function"
import Integer from "Integer"
import List from "List"
import Math from "Math"
import String from "String"



export alias Border = {
  b :: Char,
  bl :: Char,
  br :: Char,
  l :: Char,
  r :: Char,
  t :: Char,
  tl :: Char,
  tr :: Char,
}


createBorder :: Char -> Char -> Char -> Char -> Char -> Char -> Char -> Char -> Border
export createBorder = (tl, t, tr, l, r, bl, b, br) => ({ tl, t, tr, l, r, bl, b, br })


export DEFAULT_BORDER = createBorder('┌', '─', '┐', '│', '│', '└', '─', '┘')

export type BoundaryBorder
  = VerticalBoundary(Char, Char, Char)
  | HorizontalBoundary(Char, Char, Char)

createVerticalBorder :: Char -> Char -> Char -> BoundaryBorder
export createVerticalBorder = (t, c, b) => VerticalBoundary(t, c, b)

export DEFAULT_VERTICAL_BORDER = createVerticalBorder('┬', '│', '┴')

createHorizontalBorder :: Char -> Char -> Char -> BoundaryBorder
export createHorizontalBorder = (l, c, r) => HorizontalBoundary(l, c, r)

export DEFAULT_HORIZONTAL_BORDER = createHorizontalBorder('┝', '─', '┥')

export type Alignment = AlignLeft | AlignCenter | AlignRight

export alias ContentBox = {
  border :: Border,
  content :: String,
  footer :: String,
  header :: String,
  padding :: Integer,
}
export type ContentDirection = Row | Column

export alias ContainerBox = {
  boundary :: BoundaryBorder,
  boxes :: List ContentBox,
  direction :: ContentDirection,
}

export type Box = Box(ContentBox)

export alias Aligner = { content :: Alignment, footer :: Alignment, header :: Alignment }

createBox :: Integer -> Border -> String -> String -> String -> Box
export createBox = (padding, border, header, footer, content) => Box({
  border,
  header,
  footer,
  content,
  padding,
})

export unpadded = createBox(0, DEFAULT_BORDER)
export basicBox = createBox(1, DEFAULT_BORDER)


// TODO: remove these when they land in String
padStart :: Char -> Integer -> String -> String
export padStart = (pre, count, str) => {
  len = String.length(str)
  return if (len > count) {
    str
  } else do {
    prefix = String.repeat(pre, count - len)
    return prefix ++ str
  }
}

padEnd :: Char -> Integer -> String -> String
export padEnd = (post, count, str) => {
  len = String.length(str)
  return if (len > count) {
    str
  } else do {
    suffix = String.repeat(post, count - len)
    return str ++ suffix
  }
}

cap :: Char -> Char -> String -> String
export cap = (left, right, content) => pipe(
  String.appendChar(right),
  String.prependChar(left),
)(content)

// char siu!
charSeq :: Char -> Char -> Char -> Integer -> String
export charSeq = (left, middle, right, len) => pipe(
  String.repeat($, len),
  cap(left, right),
)(middle)

// TODO: once `stringWidth` works, we should remove this hack
align :: Alignment -> Char -> Integer -> Integer -> String -> String
export align = (a, fill, width, strWidth, str) => {
  maxWidth = Math.max(width, strWidth)
  sub = maxWidth - width + 1
  return if (a == AlignLeft) {
    str ++ String.repeat(fill, sub - 1)
  } else if (a == AlignCenter) do {
    count = Integer.fromFloat(Math.floor(sub / 2))
    side = String.repeat(fill, count)
    return side ++ str ++ side
  } else do {
    return String.repeat(fill, sub) ++ str
  }
}

renderContentBox :: Integer -> Aligner -> ContentBox -> String
export renderContentBox = (width, aligner, contentBox) => where(#[aligner, contentBox]) {
  #[{ content: alignment }, { border, content, padding }] =>
    where(border) {
      { b, bl, br, l, r, t, tl, tr } =>
        do {
          len = width + (padding * 2)
          top = charSeq(tl, t, tr, len)
          bottom = charSeq(bl, b, br, len)
          hPad = String.repeat(' ', padding)
          borderedLine = charSeq(l, ' ', r, len)
          vPad = padding == 0
            ? "\n"
            : pipe(
              List.repeatWith(always(borderedLine)),
              String.join("\n"),
              cap('\n', '\n'),
            )(padding)
          wrappedContent = pipe(
            mappend(align(alignment, ' ', len, len, content)),
            mappend(hPad),
            cap(r, l),
          )(hPad)
          return top ++ vPad ++ wrappedContent ++ vPad ++ bottom
        }
    }
}

renderBox :: Integer -> Aligner -> Box -> String
export renderBox = (size, aligner, box) => where(box) {
  Box({ border, header, footer, content, padding }) =>
    renderContentBox(
      size == 0 ? String.length(content) : size,
      aligner,
      { header, footer, border, padding, content },
    )
}
