import { always } from "Function"
import Integer from "Integer"
import List from "List"
import Math from "Math"
import String from "String"



export alias Border = {
  b :: Char,
  bl :: Char,
  br :: Char,
  l :: Char,
  r :: Char,
  t :: Char,
  tl :: Char,
  tr :: Char,
}


createBorder :: Char -> Char -> Char -> Char -> Char -> Char -> Char -> Char -> Border
export createBorder = (tl, t, tr, l, r, bl, b, br) => ({ tl, t, tr, l, r, bl, b, br })


export DEFAULT_BORDER = createBorder('┌', '─', '┐', '│', '│', '└', '─', '┘')

export type BoundaryBorder
  = VerticalBoundary(Char, Char, Char)
  | HorizontalBoundary(Char, Char, Char)

createVerticalBorder :: Char -> Char -> Char -> BoundaryBorder
export createVerticalBorder = (t, c, b) => VerticalBoundary(t, c, b)

export DEFAULT_VERTICAL_BORDER = createVerticalBorder('┬', '│', '┴')

createHorizontalBorder :: Char -> Char -> Char -> BoundaryBorder
export createHorizontalBorder = (l, c, r) => HorizontalBoundary(l, c, r)

export DEFAULT_HORIZONTAL_BORDER = createHorizontalBorder('┝', '─', '┥')

export type Alignment = AlignLeft | AlignCenter | AlignRight

export alias ContentBox = {
  border :: Border,
  content :: String,
  footer :: String,
  header :: String,
  padding :: Integer,
}
export type ContentDirection = Row | Column

export alias ContainerBox = {
  boundary :: BoundaryBorder,
  boxes :: List ContentBox,
  direction :: ContentDirection,
}

export type Box = Box(ContentBox)

export alias Aligner = { content :: Alignment, footer :: Alignment, header :: Alignment }

createBox :: Integer -> Border -> String -> String -> String -> Box
export createBox = (padding, border, header, footer, content) => Box({
  border,
  header,
  footer,
  content,
  padding,
})

export unpadded = createBox(0, DEFAULT_BORDER)
export basicBox = createBox(1, DEFAULT_BORDER)


// TODO: remove these when they land in String
padStart :: Char -> Integer -> String -> String
export padStart = (pre, count, str) => {
  len = String.length(str)
  return if (len > count) {
    str
  } else do {
    prefix = String.repeat(pre, count - len)
    return prefix ++ str
  }
}

padEnd :: Char -> Integer -> String -> String
export padEnd = (post, count, str) => {
  len = String.length(str)
  return if (len > count) {
    str
  } else do {
    suffix = String.repeat(post, count - len)
    return str ++ suffix
  }
}

cap :: Char -> Char -> String -> String
export cap = (left, right, content) => pipe(
  String.appendChar(right),
  String.prependChar(left),
)(content)

// char siu!
charSeq :: Char -> Char -> Char -> Integer -> String
export charSeq = (left, middle, right, len) => pipe(
  String.repeat($, len),
  cap(left, right),
)(middle)

// TODO: once `stringWidth` works, we should remove this hack
align :: Alignment -> Char -> Integer -> Integer -> String -> String
export align = (a, fill, width, strWidth, str) => {
  maxWidth = Math.max(width, strWidth)
  sub = maxWidth - width + 1
  return if (a == AlignLeft) {
    str ++ String.repeat(fill, sub - 1)
  } else if (a == AlignCenter) do {
    count = Integer.fromFloat(Math.floor(sub / 2))
    side = String.repeat(fill, count)
    return side ++ str ++ side
  } else do {
    return String.repeat(fill, sub) ++ str
  }
}

renderEdge :: String -> String -> Alignment -> Char -> Integer -> Integer -> Char -> Char -> String
renderEdge = (text, pad, alignment, fill, max, len, l, r) => text != ""
  ? pipe(
    mappend(align(alignment, fill, max, len, text)),
    mappend(pad),
    cap(l, r),
  )(pad)
  : charSeq(l, fill, r, len)


renderContentBox :: Integer -> Integer -> Integer -> Integer -> Aligner -> ContentBox -> String
export renderContentBox = (
  boxSize,
  contentWidth,
  headerWidth,
  footerWidth,
  aligner,
  contentBox
) => where(#[aligner, contentBox]) {
  #[
    { content: cAlignment, header: hAlignment, footer: fAlignment },
    { border, header, footer, content, padding },
  ] =>
    where(border) {
      { b, bl, br, l, r, t, tl, tr } =>
        do {
          dpad = padding * 2
          len = contentWidth + dpad
          hLen = headerWidth + dpad
          fLen = footerWidth + dpad
          strLen = boxSize + dpad
          hPad = String.repeat(' ', padding)
          emptyHLine = charSeq(l, ' ', r, len)
          vPad = padding == 0
            ? "\n"
            : pipe(
              List.repeatWith(always(emptyHLine)),
              String.join("\n"),
              cap('\n', '\n'),
            )(padding)
          top = renderEdge(header, hPad, hAlignment, t, strLen, hLen, tl, tr)
          bottom = renderEdge(footer, hPad, fAlignment, b, strLen, fLen, bl, br)
          wrappedContent = pipe(
            mappend(align(cAlignment, ' ', strLen, len, content)),
            mappend(hPad),
            cap(l, r),
          )(hPad)
          return top ++ vPad ++ wrappedContent ++ vPad ++ bottom
        }
    }
}

renderBox :: Integer -> Integer -> Integer -> Integer -> Aligner -> Box -> String
export renderBox = (boxSize, contentSize, headerSize, footerSize, aligner, box) => where(box) {
  Box(cBox) =>
    renderContentBox(
      // this is a hack until we have String.width
      boxSize == 0 ? String.length(cBox.content) : boxSize,
      contentSize == 0 ? String.length(cBox.content) : contentSize,
      headerSize == 0 ? String.length(cBox.content) : headerSize,
      footerSize == 0 ? String.length(cBox.content) : footerSize,
      aligner,
      cBox,
    )
}
