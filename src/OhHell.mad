import type { Either } from "Either"

import type { Card, Suit } from "./Deck"

import { EQ, GT, LT } from "Compare"
import { Left, Right } from "Either"
import Fn from "Function"
import IO from "IO"
import List from "List"
import Math from "Math"
import { Just, Nothing, fromMaybe } from "Maybe"
import Random from "Random"

import { Ace } from "./Deck"
import Deck from "./Deck"



export type Player = Player(String, List Card)

export alias InitialState = {
  cardsPerPlayer :: Integer,
  cardsPerRound :: List Integer,
  players :: List Player,
  trump :: Suit,
}

export type GameError = Error(Integer, String) | GenericError

getHumanError :: GameError -> String
export getHumanError = where {
  Error(_, s) =>
    s

  GenericError =>
    "An error occurred!"
}

// If three to five play, 10 cards are dealt to each player in the first deal; if six play, 8 cards, and, if seven play, 7 cards.
cardsPerTotalPlayers :: Integer -> Integer
export cardsPerTotalPlayers = (i) => if (i >= 3 && i <= 5) {
  10
} else if (i == 6) {
  8
} else if (i == 7) {
  7
} else {
  -1
}

roundsPerTotalPlayers :: Integer -> List Integer
export roundsPerTotalPlayers = (i) => {
  max = cardsPerTotalPlayers(i) + 1
  return if (max > 0) {
    List.concat(List.reverse(List.range(2, max)), List.range(1, max))
  } else {
    [max]
  }
}

__sum :: List Integer -> Integer
export __sum = List.reduce(Math.add, 0)

initialDeal :: Random -> List String -> Either GameError InitialState
export initialDeal = (rand, playerNames) => {
  totalPlayers = List.length(playerNames)
  cardsPerPlayer = cardsPerTotalPlayers(totalPlayers)
  return pipe(
    Random.shuffle($, rand),
    Deck.deal(cardsPerPlayer, totalPlayers),
    where {
      Just(#[hands, undealt]) =>
        Right({
          players: pipe(
            List.zip(playerNames),
            map(where { #[name, hand] => Player(name, hand) }),
          )(hands),
          trump: pipe(
            List.first,
            map(Deck.getSuit),
            fromMaybe(Deck.Joker),
          )(undealt),
          cardsPerPlayer,
          cardsPerRound: roundsPerTotalPlayers(totalPlayers),
        })

      Nothing =>
        Left(Error(2, `Unable to deal hands for ${show(totalPlayers)} players.`))
    },
  )(Deck.DECK)
}

// ActivePlayer
export type PlayerState = Initial | Bet(Integer) | Played
export type ActivePlayer = ActivePlayer(Player, PlayerState, Integer)

alias PlayState = {
  ...InitialState,
  bets :: List Integer,
  players :: List ActivePlayer,
  round :: Integer,
  trump :: Suit,
}

prepForBetting :: InitialState -> PlayState
export prepForBetting = (state) => (
  { ...state, bets: [], players: map((p) => ActivePlayer(p, Initial, 0), state.players), round: 0 }
)

isTrump :: Suit -> Card -> Boolean
export isTrump = (s, c) => pipe(
  Deck.getSuit,
  Fn.equals(s),
)(c)


canBet :: Integer -> List Integer -> Boolean
export canBet = (goal, xs) => __sum(xs) != goal

export alias HandWeights = {
  faceCards :: Integer,
  highestBet :: Integer,
  trumpCards :: Integer,
  trumpFaceCards :: Integer,
}

__largest :: List Integer -> Integer
export __largest = pipe(
  List.sortBy((a, b) => a == b ? EQ : a < b ? GT : LT),
  List.first,
  fromMaybe(0),
)

weighHand :: Suit -> List Card -> List Integer -> HandWeights
export weighHand = (trump, cards, bets) => {
  sorted = Deck.sortWithTrump(trump, cards)
  trumpCards = Deck.filterBySuit(trump, sorted)
  faceCards = Deck.getFaceCards(sorted)
  return {
    trumpCards: List.length(trumpCards),
    faceCards: List.length(faceCards),
    highestBet: __largest(bets),
    trumpFaceCards: pipe(
      Deck.filterBySuit(trump),
      List.length,
    )(faceCards),
  }
}

/**
 * If a player has great trump cards (starting with an ace), what is the contiguous set of
 * cards that will beat all others? i.e. If they have ace through queen of trump, then
 * that would guarantee at least 3 tricks (A + K + Q)
 * This function will only search from the top down, so if the player is missing the ace
 * it will return an empty list
 */
winningCards :: Suit -> List Card -> List Card
export winningCards = (trump, cards) => {
  aceOfTrump = Deck.Card(trump, Ace)
  hasAce = Deck.includes(aceOfTrump, cards)
  return if (!hasAce) {
    []
  } else {
    pipe(
      Deck.filterBySuit(trump),
      Deck.sortWithTrump(trump),
      List.reduce(
        (stack, card) => pipe(
          List.first,
          fromMaybe(Deck.Card(Deck.Joker, Deck.InvalidDenomination)),
          Deck.isConsecutiveSameSuit(true, card),
          (yes) => yes ? List.append(card, stack) : stack,
        )(stack),
        [aceOfTrump],
      ),
    )(cards)
  }
}


judgeByWeight :: Random -> PlayState -> List Integer -> HandWeights -> Integer
export judgeByWeight = (rand, state, bets, weights) => {
  totalPlayers = List.length(state.players)
  max = pipe(
    List.nth(state.round),
    fromMaybe(totalPlayers),
  )(state.cardsPerRound)
  IO.cTrace(`max`, max)
  currentSum = __sum(bets)
  IO.cTrace(`>>>`, currentSum)
  upperLimit = max - currentSum
  // likely bets: trump face cards

  return Random.integer(weights.trumpFaceCards, upperLimit, rand)
}
