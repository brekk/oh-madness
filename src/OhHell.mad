import type { Either } from "Either"
import type { Maybe } from "Maybe"

import type { Seed } from "Random"

import type { Card, Suit } from "./Deck"

import { EQ, GT, LT } from "Compare"
import { Left, Right } from "Either"
import Fn from "Function"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"

import Random from "Random"

import Deck from "./Deck"



export type Player = Player(String, List Card)

export alias InitialState = { cardsPerPlayer :: Integer, players :: List Player, trump :: Suit }

export type GameError = Error(Integer, String) | GenericError

initialDeal :: Seed -> Integer -> List String -> Either GameError InitialState
export initialDeal = (seed, cardsPerPlayer, playerNames) => {
  totalPlayers = List.length(playerNames)
  return pipe(
    Deck.shuffle(seed),
    Deck.deal(cardsPerPlayer, totalPlayers),
    where {
      Just(#[hands, undealt]) =>
        Right({
          players: pipe(
            List.zip(playerNames),
            map(where { #[name, hand] => Player(name, hand) }),
          )(hands),
          trump: pipe(
            List.first,
            map(Deck.getSuit),
          )(undealt),
          cardsPerPlayer,
        })

      Nothing =>
        Left(Error(1, `Unable to deal hands for ${show(totalPlayers)} players.`))
    },
    chain(
      (state) => where(state.trump) {
        Nothing =>
          Left(Error(2, "Trump suit not found."))

        Just(suit) =>
          Right({ ...state, trump: suit })
      },
    ),
  )(Deck.DECK)
}

// ActivePlayer
export type PlayerState = Initial | Bet(Integer) | Played | ChangeTrumpBet(Suit, Integer)
export type ActivePlayer = ActivePlayer(Player, PlayerState, Integer)

alias PlayState = {
  bets :: List Integer,
  cardsPerPlayer :: Integer,
  players :: List ActivePlayer,
  trump :: Suit,
}

prepForBetting :: InitialState -> PlayState
export prepForBetting = (state) => (
  { ...state, bets: [], players: map((p) => ActivePlayer(p, Initial, 0), state.players) }
)

isTrump :: Suit -> Card -> Boolean
export isTrump = (s, c) => pipe(
  Deck.getSuit,
  Fn.equals(s),
)(c)


canBet :: Integer -> List Integer -> Boolean
export canBet = (goal, xs) => List.reduce((sum, a) => sum + a, 0, xs) != goal

export alias HandWeights = {
  faceCards :: Integer,
  highestBet :: Integer,
  trumpCards :: Integer,
  trumpFaceCards :: Integer,
}

weighHand :: Suit -> List Card -> List Integer -> HandWeights
export weighHand = (trump, cards, bets) => {
  sorted = Deck.sortWithTrump(trump, cards)
  trumpCards = Deck.filterBySuit(trump, sorted)
  faceCards = Deck.getFaceCards(sorted)
  highestBet = pipe(
    List.sortBy((a, b) => a == b ? EQ : a < b ? GT : LT),
    List.first,
    fromMaybe(0),
  )(bets)
  return {
    trumpCards: List.length(trumpCards),
    faceCards: List.length(faceCards),
    highestBet,
    trumpFaceCards: pipe(
      Deck.filterBySuit(trump),
      List.length,
    )(faceCards),
  }
}
