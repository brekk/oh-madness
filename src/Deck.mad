import type { Maybe } from "Maybe"
import type { Random } from "Random"

import { EQ, GT, LT } from "Compare"
import Fn from "Function"
import IO from "IO"
import List from "List"
import Math from "Math"
import { Just, Nothing } from "Maybe"
import Random from "Random"



export type Suit = Clubs | Diamonds | Hearts | Spades | Joker
export type Denomination
  = NoFace(Integer)
  | Jack
  | Queen
  | King
  | Ace
  | Wildcard
  | InvalidDenomination

export type Card = Card(Suit, Denomination)

getSuit :: Card -> Suit
export getSuit = where {
  Card(s, _) =>
    s
}

getValue :: Card -> Denomination
export getValue = where {
  Card(_, v) =>
    v
}

getOrdinalValue :: Boolean -> Denomination -> Integer
export getOrdinalValue = (aceHigh, d) => where(d) {
  NoFace(x) =>
    x

  Jack =>
    11

  Queen =>
    12

  King =>
    13

  Ace =>
    aceHigh ? 14 : 1

  Wildcard =>
    0

  InvalidDenomination =>
    -1
}


export getOrdinal = getOrdinalValue(true)
export getOrdinalLow = getOrdinalValue(false)


ordinalToDenomination :: Integer -> Denomination
export ordinalToDenomination = (i) => if (i == 14 || i == 1) {
  Ace
} else if (i == 13) {
  King
} else if (i == 12) {
  Queen
} else if (i == 11) {
  Jack
} else if (i == 0) {
  Wildcard
} else if (i < 0 || i > 14) {
  InvalidDenomination
} else {
  NoFace(i)
}

__makeFullSuit :: Suit -> List Card
export __makeFullSuit = (s) => [
  ...map((v) => Card(s, NoFace(v)), List.range(2, 11)),
  Card(s, Jack),
  Card(s, Queen),
  Card(s, King),
  Card(s, Ace),
]

DECK :: List Card
export DECK = [
  ...__makeFullSuit(Clubs),
  ...__makeFullSuit(Diamonds),
  ...__makeFullSuit(Hearts),
  ...__makeFullSuit(Spades),
]

DECK_WITH_JOKERS :: List Card
export DECK_WITH_JOKERS = [...DECK, Card(Joker, Wildcard), Card(Joker, Wildcard)]



sortDescWithTrump :: Boolean -> Suit -> List Card -> List Card
export sortDescWithTrump = (aceHigh, trumpSuit, cards) => List.sortBy(
  (a, b) => where(#[a, b]) {
    #[Card(d1, v1), Card(d2, v2)] =>
      do {
        x = getOrdinalValue(aceHigh, v1)
        y = getOrdinalValue(aceHigh, v2)
        trump1 = d1 == trumpSuit
        trump2 = d2 == trumpSuit
        return if (trump1 && !trump2) {
          LT
        } else if (trump2 && !trump1) {
          GT
        } else {
          x == y ? EQ : x < y ? GT : LT
        }
      }
  },
  cards,
)
export sortWithTrump = sortDescWithTrump(true)
export sortLowWithTrump = sortDescWithTrump(false)

sortDesc :: Boolean -> List Card -> List Card
export sortDesc = (aceHigh, cards) => List.sortBy(
  (a, b) => where(#[a, b]) {
    #[Card(d1, v1), Card(d2, v2)] =>
      do {
        x = getOrdinalValue(aceHigh, v1)
        y = getOrdinalValue(aceHigh, v2)
        return x == y ? EQ : x < y ? GT : LT
      }
  },
  cards,
)
export sort = sortDesc(true)
export sortLow = sortDesc(false)

includes :: Card -> List Card -> Boolean
export includes = (c, cs) => where(c) {
  Card(d, v) =>
    Fn.any(where { Card(d2, v2) => d == d2 && v == v2 }, cs)
}


cut :: Integer -> List a -> Maybe #[List a, List a]
export cut = (a, xs) => {
  len = List.length(xs)
  return if (a <= len && a > -1) {
    Just(#[List.slice(0, a - 1, xs), List.slice(a, len, xs)])
  } else {
    Nothing
  }
}


recut :: Integer -> Integer -> List a -> Maybe (List (List a))
export recut = (per, times, xs) => if (per > 0 && times > 0 && per * times <= List.length(xs)) {
  pipe(
    List.repeatWith((i) => List.slice(i * (per - 1), (i + 1) * (per - 1), xs)),
    Just,
  )(times)
} else {
  Nothing
}

deal :: Integer -> Integer -> List Card -> Maybe #[List (List Card), List Card]
export deal = (perPlayer, totalPlayers, cards) => {
  totalCards = List.length(cards)
  toDeal = perPlayer * totalPlayers
  return if (perPlayer < 0 || totalPlayers < 0 || totalCards < toDeal) {
    Nothing
  } else {
    pipe(
      cut(toDeal),
      chain(
        where {
          #[hands, remainder] =>
            where(recut(perPlayer, totalPlayers, hands)) {
              Just(dealt) =>
                Just(#[dealt, remainder])

              _ =>
                Nothing
            }
        },
      ),
    )(cards)
  }
}

isSuit :: Suit -> Card -> Boolean
export isSuit = (s, c) => pipe(
  getSuit,
  Fn.equals(s),
)(c)

filterBySuit :: Suit -> List Card -> List Card
export filterBySuit = (s, cs) => List.filter(isSuit(s), cs)

rejectBySuit :: Suit -> List Card -> List Card
export rejectBySuit = (s, cs) => List.reject(isSuit(s), cs)

isFaceCard :: Card -> Boolean
export isFaceCard = where {
  Card(_, NoFace(_)) =>
    false

  Card(_, InvalidDenomination) =>
    false

  Card(_, Wildcard) =>
    false

  _ =>
    true
}
isNonStandardDenomination :: Card -> Boolean
export isNonStandardDenomination = where {
  Card(_, InvalidDenomination) =>
    true

  Card(_, Wildcard) =>
    true

  _ =>
    false
}

getFaceCards :: List Card -> List Card
export getFaceCards = List.filter(isFaceCard)

getNonFaceCards :: List Card -> List Card
export getNonFaceCards = pipe(
  List.reject(isFaceCard),
  List.reject(isNonStandardDenomination),
)

isConsecutive :: Boolean -> Boolean -> Card -> Card -> Boolean
export isConsecutive = (matchSuit, aceHigh, c1, c2) => {
  ord = getOrdinalValue(aceHigh)
  return where(#[c1, c2]) {
    #[Card(s1, v1), Card(s2, v2)] =>
      (matchSuit ? s1 == s2 : true) && Math.abs(ord(v1) - ord(v2)) == 1
  }
}
export isConsecutiveSameSuit = isConsecutive(true)
export isConsecutiveAnySuit = isConsecutive(false)

/**
 * Finds "runs" of cards: cards in consecutive order
 *  
 */
getContiguous :: Boolean -> Boolean -> List Card -> List (List Card)
export getContiguous = (matchSuit, aceHigh, cards) => {
  ord = getOrdinalValue(aceHigh)
  conseq = isConsecutive(matchSuit, aceHigh)
  return pipe(
    List.reduce(
      (stacks, card) => if (List.isEmpty(stacks)) {
        [[card]]
      } else {
        // not yet right
        where(card) {
          Card(s, v) =>
            pipe(
              IO.cTrace("before"),
              map(List.filter(conseq(card))),
              IO.cTrace("after"),
            )(stacks)
        }
      },
      [],
    ),
  )(cards)
}
