import type { Maybe } from "Maybe"
import type { Random } from "Random"

import Compare from "Compare"
import { EQ, GT, LT } from "Compare"
import Fn from "Function"
import IO from "IO"
import List from "List"
import Math from "Math"
import { Just, Nothing } from "Maybe"
import Random from "Random"
import Terminal from "Terminal"



export type Suit = Clubs | Diamonds | Hearts | Spades | Joker
export type Rank = NoFace(Integer) | Jack | Queen | King | Ace | Wildcard | InvalidRank

export type Card = Card(Suit, Rank)

getSuit :: Card -> Suit
export getSuit = where {
  Card(s, _) =>
    s
}

getRank :: Card -> Rank
export getRank = where {
  Card(_, v) =>
    v
}

getOrdinalRank :: Boolean -> Rank -> Integer
export getOrdinalRank = (aceHigh, d) => where(d) {
  NoFace(x) =>
    x

  Jack =>
    11

  Queen =>
    12

  King =>
    13

  Ace =>
    aceHigh ? 14 : 1

  Wildcard =>
    0

  InvalidRank =>
    -1
}


export getOrdinal = getOrdinalRank(true)
export getOrdinalLow = getOrdinalRank(false)


ordinalToRank :: Integer -> Rank
export ordinalToRank = (i) => if (i == 14 || i == 1) {
  Ace
} else if (i == 13) {
  King
} else if (i == 12) {
  Queen
} else if (i == 11) {
  Jack
} else if (i == 0) {
  Wildcard
} else if (i < 0 || i > 14) {
  InvalidRank
} else {
  NoFace(i)
}

__makeFullSuit :: Suit -> List Card
export __makeFullSuit = (s) => [
  ...map((v) => Card(s, NoFace(v)), List.range(2, 11)),
  Card(s, Jack),
  Card(s, Queen),
  Card(s, King),
  Card(s, Ace),
]

DECK :: List Card
export DECK = [
  ...__makeFullSuit(Clubs),
  ...__makeFullSuit(Diamonds),
  ...__makeFullSuit(Hearts),
  ...__makeFullSuit(Spades),
]

DECK_WITH_JOKERS :: List Card
export DECK_WITH_JOKERS = [...DECK, Card(Joker, Wildcard), Card(Joker, Wildcard)]

sortDescWithTrump :: Boolean -> Suit -> List Card -> List Card
export sortDescWithTrump = (aceHigh, trumpSuit, cards) => List.sortBy(
  (a, b) => where(#[a, b]) {
    #[Card(d1, v1), Card(d2, v2)] =>
      do {
        x = getOrdinalRank(aceHigh, v1)
        y = getOrdinalRank(aceHigh, v2)
        trump1 = d1 == trumpSuit
        trump2 = d2 == trumpSuit
        return if (trump1 && !trump2) {
          LT
        } else if (trump2 && !trump1) {
          GT
        } else {
          x == y ? EQ : x < y ? GT : LT
        }
      }
  },
  cards,
)
export sortWithTrump = sortDescWithTrump(true)
export sortLowWithTrump = sortDescWithTrump(false)

sortDesc :: Boolean -> List Card -> List Card
export sortDesc = (aceHigh, cards) => List.sortBy(
  (a, b) => where(#[a, b]) {
    #[Card(d1, v1), Card(d2, v2)] =>
      do {
        x = getOrdinalRank(aceHigh, v1)
        y = getOrdinalRank(aceHigh, v2)
        return x == y ? EQ : x < y ? GT : LT
      }
  },
  cards,
)
export sort = sortDesc(true)
export sortLow = sortDesc(false)

includes :: Card -> List Card -> Boolean
export includes = (c, cs) => where(c) {
  Card(d, v) =>
    Fn.any(where { Card(d2, v2) => d == d2 && v == v2 }, cs)
}


cut :: Integer -> List a -> Maybe #[List a, List a]
export cut = (a, xs) => {
  len = List.length(xs)
  return if (a <= len && a > -1) {
    Just(#[List.slice(0, a - 1, xs), List.slice(a, len, xs)])
  } else {
    Nothing
  }
}

// recut :: Integer -> Integer -> List a -> Maybe (List (List a))
// export recut = (per, times, xs) => if (per > 0 && times > 0 && per * times <= List.length(xs)) {
//   pipe(
//     List.repeatWith((i) => List.slice(i * per, ((i + 1) * per) - 1, xs)),
//     Just,
//   )(times)
// } else {
//   Nothing
// }

// remove if bifunctor tuples land
mapFst :: (a -> c) -> #[a, b] -> #[c, b]
mapFst = (fn, tuple) => where(tuple) {
  #[a, b] =>
    #[fn(a), b]
}

__recut :: Integer -> Integer -> List a -> List (List a)
export __recut = (per, times, xs) => List.repeatWith(
  (i) => List.slice(i * per, ((i + 1) * per) - 1, xs),
  times,
)

deal :: Integer -> Integer -> List Card -> Maybe #[List (List Card), List Card]
export deal = (perPlayer, totalPlayers, cards) => {
  totalCards = List.length(cards)
  toDeal = perPlayer * totalPlayers
  return if (perPlayer < 0 || totalPlayers < 0 || totalCards < toDeal) {
    Nothing
  } else {
    pipe(
      cut(toDeal),
      map(mapFst(__recut(perPlayer, totalPlayers))),
    )(cards)
  }
}

isSuit :: Suit -> Card -> Boolean
export isSuit = (s, c) => pipe(
  getSuit,
  Fn.equals(s),
)(c)

filterBySuit :: Suit -> List Card -> List Card
export filterBySuit = (s, cs) => List.filter(isSuit(s), cs)

rejectBySuit :: Suit -> List Card -> List Card
export rejectBySuit = (s, cs) => List.reject(isSuit(s), cs)

isFaceCard :: Card -> Boolean
export isFaceCard = where {
  Card(_, NoFace(_)) =>
    false

  Card(_, InvalidRank) =>
    false

  Card(_, Wildcard) =>
    false

  _ =>
    true
}
isNonStandardRank :: Card -> Boolean
export isNonStandardRank = where {
  Card(_, InvalidRank) =>
    true

  Card(_, Wildcard) =>
    true

  _ =>
    false
}

getFaceCards :: List Card -> List Card
export getFaceCards = List.filter(isFaceCard)

getNonFaceCards :: List Card -> List Card
export getNonFaceCards = pipe(
  List.reject(isFaceCard),
  List.reject(isNonStandardRank),
)

isConsecutive :: Boolean -> Boolean -> Card -> Card -> Boolean
export isConsecutive = (matchSuit, aceHigh, c1, c2) => {
  ord = getOrdinalRank(aceHigh)
  return where(#[c1, c2]) {
    #[Card(s1, v1), Card(s2, v2)] =>
      (matchSuit ? s1 == s2 : true) && Math.abs(ord(v1) - ord(v2)) == 1
  }
}
export isConsecutiveSameSuit = isConsecutive(true)
export isConsecutiveAnySuit = isConsecutive(false)

/*Fn.ifElse(
List.isEmpty,
List.append([card]),
map(
pipe(
Fn.when(
pipe(
Fn.any(conseq(card)),
IO.trace("checked!"),
),
List.append(card),
),
IO.trace("post!"),
),
),
)(stack)*/

/**
 * Finds "straights" of cards: cards in consecutive order
 *  
 */
getConsecutiveRuns :: Boolean -> Boolean -> List Card -> List (List Card)
export getConsecutiveRuns = (matchSuit, aceHigh, cards) => {
  conseq = isConsecutive(matchSuit, aceHigh)
  return pipe(
    sortDesc(matchSuit),
    List.reduce(
      (stack, card) => {
        matched = false
        restack = map(
          Fn.when(
            Fn.any(conseq(card)),
            pipe(
              List.append(card),
              (x) => {
                matched := true
                return x
              },
            ),
          ),
        )(stack)
        return if (matched) {
          restack
        } else {
          List.append([card], stack)
        }
      },
      [],
    ),
  )(cards)
}

export getStraightFlushes = getConsecutiveRuns(true)
export getStraights = getConsecutiveRuns(false)

filterListsByLimit :: Integer -> List (List Card) -> List (List Card)
export filterListsByLimit = (limit, stacks) => List.reject(
  pipe(
    List.length,
    Compare.lt($, limit),
  ),
  stacks,
)
