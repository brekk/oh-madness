import type { Maybe } from "Maybe"

import type { Card, Suit } from "./Card"

import Compare from "Compare"
import { EQ, GT, LT } from "Compare"
import Fn from "Function"
import IO from "IO"
import List from "List"
import Math from "Math"
import { Just, Nothing } from "Maybe"
import Short from "Short"

import {
  Ace,
  Card,
  Clubs,
  Diamonds,
  Hearts,
  InvalidRank,
  Jack,
  Joker,
  King,
  NoFace,
  Queen,
  Spades,
  Wildcard,
} from "./Card"
import Card from "./Card"



__makeFullSuit :: Suit -> List Card
export __makeFullSuit = (s) => [
  ...map(
    pipe(
      Short.fromInteger,
      (v) => Card(s, NoFace(v)),
    ),
    List.range(2, 11),
  ),
  Card(s, Jack),
  Card(s, Queen),
  Card(s, King),
  Card(s, Ace),
]

DECK :: List Card
export DECK = [
  ...__makeFullSuit(Clubs),
  ...__makeFullSuit(Diamonds),
  ...__makeFullSuit(Hearts),
  ...__makeFullSuit(Spades),
]

DECK_WITH_JOKERS :: List Card
export DECK_WITH_JOKERS = [...DECK, Card(Joker, Wildcard), Card(Joker, Wildcard)]

sortDescWithTrump :: Boolean -> Suit -> List Card -> List Card
export sortDescWithTrump = (aceHigh, trumpSuit, cards) => List.sortBy(
  (a, b) => where(#[a, b]) {
    #[Card(d1, v1), Card(d2, v2)] =>
      do {
        x = Card.ordinalRank(aceHigh, v1)
        y = Card.ordinalRank(aceHigh, v2)
        trump1 = d1 == trumpSuit
        trump2 = d2 == trumpSuit
        return if (trump1 && !trump2) {
          LT
        } else if (trump2 && !trump1) {
          GT
        } else {
          x == y ? EQ : x < y ? GT : LT
        }
      }
  },
  cards,
)
export sortWithTrump = sortDescWithTrump(true)
export sortLowWithTrump = sortDescWithTrump(false)

sortDesc :: Boolean -> List Card -> List Card
export sortDesc = (aceHigh, cards) => List.sortBy(
  (a, b) => where(#[a, b]) {
    #[Card(d1, v1), Card(d2, v2)] =>
      do {
        x = Card.ordinalRank(aceHigh, v1)
        y = Card.ordinalRank(aceHigh, v2)
        return x == y ? EQ : x < y ? GT : LT
      }
  },
  cards,
)
export sort = sortDesc(true)
export sortLow = sortDesc(false)

has :: Card -> List Card -> Boolean
export has = (c, cs) => where(c) {
  Card(d, v) =>
    List.any(where { Card(d2, v2) => d == d2 && v == v2 }, cs)
}
anyMatchingRank :: Card -> List Card -> Boolean
export anyMatchingRank = (c, cs) => where(c) {
  Card(_, v) =>
    List.any(where { Card(_, v2) => v == v2 }, cs)
}

// remove if bifunctor tuples land
mapFst :: (a -> c) -> #[a, b] -> #[c, b]
mapFst = (fn, tuple) => where(tuple) {
  #[a, b] =>
    #[fn(a), b]
}

__recut :: Integer -> Integer -> List a -> List (List a)
export __recut = (per, times, xs) => List.repeatWith(
  (i) => List.slice(i * per, ((i + 1) * per) - 1, xs),
  times,
)

deal :: Integer -> Integer -> List Card -> Maybe #[List (List Card), List Card]
export deal = (perPlayer, totalPlayers, cards) => {
  totalCards = List.length(cards)
  toDeal = perPlayer * totalPlayers
  return if (perPlayer < 0 || totalPlayers < 0 || totalCards < toDeal) {
    Nothing
  } else {
    pipe(
      List.cut(toDeal),
      map(mapFst(__recut(perPlayer, totalPlayers))),
    )(cards)
  }
}



filterBySuit :: Suit -> List Card -> List Card
export filterBySuit = (s, cs) => List.filter(Card.isSuit(s), cs)

rejectBySuit :: Suit -> List Card -> List Card
export rejectBySuit = (s, cs) => List.reject(Card.isSuit(s), cs)

getFaceCards :: List Card -> List Card
export getFaceCards = List.filter(Card.isFaceCard)

getNonFaceCards :: List Card -> List Card
export getNonFaceCards = List.filter(Card.isNoFaceCard)

/**
 * Finds "straights" of cards: cards in consecutive order
 *  
// this is incomplete / incorrect currently
getConsecutiveRuns :: Boolean -> Boolean -> List Card -> List (List Card)
export getConsecutiveRuns = (matchSuit, aceHigh, cards) => pipe(
  sortDesc(matchSuit),
  List.reduce(
    (stack, card) => {
      matched = false
      restack = map(
        Fn.when(
          List.any(isConsecutive(matchSuit, aceHigh, card)),
          pipe(
            List.append(card),
            (x) => {
              matched := true
              return x
            },
          ),
        ),
      )(stack)
      return if (matched) {
        restack
      } else {
        List.append([card], stack)
      }
    },
    [],
  ),
)(cards)
*/

dedupe :: List Card -> List Card
export dedupe = List.uniqueBy(Card.sameCard)

findSameRank :: List Card -> List (List Card)
export findSameRank = pipe(
  List.groupBy(Card.sameRank),
  List.reject(
    pipe(
      List.length,
      Fn.equals(1),
    ),
  ),
)
